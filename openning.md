# 러스트

러스트는 컴퓨터 시스템을 저수준에서 운영하는 소프트웨어를 만드는 시스템
프로그래밍 언어입니다. 요즘은 여러 프로그래밍 언어 순위에서 상위에 위치하며
특히 블록체인에서는 블록체인 노드(클라이언트)와 스마트 컨트랙트를 만드는데 많이
활용되고 있습니다.

러스트는 파이어폭스 웹브라우저를 개발하던 모질라의 그레이든 호어(Graydon
Hoare)가 2006년 개인 프로젝트로 시작했고, 2009년 모질라의 공식 프로젝트가
되었습니다. C++로 개발하던 모질라는 새로운 웹브라우저 렌더링 엔진 Servo를
개발하려고 러스트를 발전시켰습니다. 당시 삼성전자도 개발에 참여하여 이른 시기
한국 러스트 사용자 그룹이 왕성히 활동했습니다. 한편 호어는 후에 리플의 포크인
스텔라에 합류했고, 애플에서 스위프트 프로그래밍 언어 개발에도 참여했습니다.

블록체인에서 초기 러스트 활용 사례는, 패리티의 패리티(Parity) 이더리움
노드입니다. 이후 패리티가 폴카닷을 만들면서 패리티 개발을 중단하고,
[OpenEthereum](https://github.com/openethereum/openethereum)으로 개명하여
외부에서 개발을 이어나갔지만 현재는 아쉽게도 개발이 중단되었습니다. (최근
크립토 투자사인 패러다임이 [reth](https://github.com/paradigmxyz/reth)란
이더리움 클라이언트를 러스트로 개발하기 시작했습니다. 패러다임은
[Foundry](https://github.com/foundry-rs)라는 이더리움 스마트 컨트랙트 개발
도구도 러스트로 만듭니다. 이더리움 2.0 합의 클라이언트 중에 러스트로 개발한
[Lighthouse](https://github.com/sigp/lighthouse)가 있습니다.) 2018년 당시
논스에 있었던 코드박스도 [CodeChain](https://github.com/CodeChain-io/codechain)
체인을 러스트로 개발하기 시작했습니다. (현재는 두나무 자회사로 체인 개발을
중단했습니다. 여담으로 저는 코드박스 창업 전 서광렬 대표님에게 프로그래밍을
많이 배웠습니다.) 현재는 [솔라나](https://github.com/solana-labs/solana),
[폴카닷](https://github.com/paritytech/polkadot),
[니어](https://github.com/near/nearcore) 그리고 페이스북/메타
[리브라/디엠](https://github.com/diem/diem)의 후손인
[앱토스](https://github.com/aptos-labs/aptos-core)와
[수이](https://github.com/MystenLabs/sui) 등 다양한 블록체인 프로토콜이
러스트로 개발되었고, 솔라나와 (코스모스 생태계의)
[Cosmwasm](https://github.com/CosmWasm/cosmwasm) 등 스마트 컨트랙트를 러스트로
개발합니다. 리브라/디엠의 스마트 컨트랙트 언어인
[무브(Move)](https://github.com/move-language/move)도 러스트의 영향을 매우 크게
받아서 (러스트의 쉬운 버전 느낌) 러스트를 안다면 쉽게 적응할 수 있습니다.
폴카닷의 패러체인을 만드는
[Substrate](https://github.com/paritytech/substrate)도 러스트 기반입니다.

더보기:
[Awesome Blockchain Rust](https://github.com/rust-in-blockchain/awesome-blockchain-rust)

## 러스트 vs Go

러스트 만큼 인기가 있고 블록체인에서도 많이 사용하는 시스템 프로그래밍 언어로
구글이 만든 Go가 있습니다. Go와 러스트 모두 컴파일 언어이고, 컴파일하면 외부
라이브러리에 의존하지 않는 단일 실행파일을 만듭니다. (실행파일 크기가 커지지만,
동적 라이브러리 파일이 변해도 영향을 받지 않습니다.)

둘의 가장 큰 차이는 메모리 관리입니다. Go는 자바처럼 가비지 컬렉션을 합니다.
(그래서 Go가 배우기 쉬웠습니다. Go는 마치 'PL(프로그래밍 언어)이 뭐야? 난
늬들이 태어나기 전부터 프로그래밍했어'라는 노인이 깍은 방망이 같은 느낌)
러스트는 가비지 컬렉션이 없지만, 요즘 언어답게 프로그래머가 직접 메모리를
관리할 필요는 없습니다. 컴파일할 때 메모리 사용을 추적하고 메모리를 잘못
사용하면 컴파일이 안됩니다.

C에서 함수가 작업에 필요한 메모리를 할당하는 경우는 다양합니다.
* 함수를 호출한 쪽에서 메모리를 할당해서 넘겨주고, 나중에 마찬가지로 호출한
  쪽에서 메모리 해제
* 함수에서 메모리를 할당해서 반환하고, 함수를 호출한 쪽에서 해제
* 함수에서 메모리를 할당해서 반환하지만, (함수를 호출한 쪽에서 다 사용했다고
  알린 후) 함수에서 해제
* 함수에서 정적 메모리를 유지하고 메모리 주소를 반환, 정적 메모리이기 때문에
  해제하면 안됨

함수 설명을 꼼꼼히 읽고 프로그래머가 주의를 기울이지 않으면 메모리 오류로
프로그램이 죽기 십상이었습니다. 그래서 reference count를 가진 C++ smart
pointer나 Valgrind 같은 memory leak 디버거를 동원하지만 문제가 사라지지는
않습니다. 현대 가장 복잡한 소프트웨어 중 하나가 된 웹브라우저를 개발하는 분들도
당연히 메모리 문제에 시달렸고, 러스트를 만드는 동기가 되었습니다.

러스트는 메모리 할당과 사용을 추적해서 메모리를 더 이상 사용하지 않는게
확실해지면 메모리를 해제합니다. 실행 시점에 (run-time) 메모리 관리를 하는
가비지 컬렉터와 달리 컴파일 시점에 (compile-time) 결정됩니다. 요즘 흔해진
동시성 프로그래밍을 할 때도 러스트는 좋습니다. 여러 쓰레드가 동일한 메모리를
아무렇게나 사용하면 컴파일 자체가 안됩니다. 일단 컴파일되면 race condition 등
발견하기 힘든 동시성 버그가 없다고 안심할 수 있습니다. 효율적이고 실행파일에
가비지 컬렉터가 들어갈 필요가 없다는 점은 C에 이어 리눅스 커널을 작성할 때
사용할 수 있는 두번째 공식 언어가 되는데 도움이 되었습니다.

## 자료형에 엄격

자료형은 컴퓨터에 있는 값을 어떻게 해석하고, 그 값에 어떤 연산을 할 수 있는지
결정합니다.

> (representation) 2진수 11100001 이, 8bit signed integer라면 -31, 8bit
  unsigned integer라면 225, latin-1 character라면 á<br>
> (operation) 숫자 자료형은 사칙연산와 비교 가능, 사각형 자료형은 면적 계산과
  면적 비교 가능, 문자열 자료형은 자르기, 붙이기, 찾기, 비교, 앞뒤 공백문자
  제거 가능

모든 프로그래밍 언어에는 자료형이 있지만 자료형을 엄격하게 따지지 않는 언어에
익숙한 분은 러스트에 당황할 수 있습니다. 러스트를 컴파일하면 장황하게 오류가
발생하고, 이중 상당수는 자료형에 대한 오류입니다. (다행히 현대 언어답게 어떻게
고치면 좋을지 비교적 정확히 알려주기는 합니다.) 심지어 크기가 다른 정수형끼리
연산도 할 수 없습니다. 명시적으로 자료형을 변경해서 맞추어주어야 합니다. 그래서
처음 개발할 때는 컴파일러 오류를 없애려고 마치 퍼즐처럼 자료형을 맞추는데
고생했고, 러스트가 어렵다고 느끼는 부분인 것 같습니다. 자료형에 엄격해서 버그를
미연에 방지하는게 장점이라고 생각하는 사람에게는 러스트가 좋지만, 이런 부분이
갑갑한 분에게는 단점으로 다가올 수 있습니다.

여러 쓰레드가 동시에 읽고 쓸 수 있는 값을 예로 들면, 다른 언어에서는 값을
사용하기 전에 먼저 잠금하라고(lock, 찜하라고) 안내하지만 강제하지는 않아서
프로그래머가 실수던 고의던 간에 잠금 없이 값을 읽고 쓰는 방법이 있습니다.
러스트는 잠금해야만 읽고 쓸 수 있는 자료형이 튀어나오기 때문에 자료형 수준에서
잠금 없이 값에 접근을 차단합니다. 즉, 컴파일이 안됩니다. 자료형이 복잡하더라도
컴파일시 검사할 때만 사용하고 실제 프로그램에는 자료형 정보가 대부분 사라지기
(type erasure) 때문에 프로그램을 실행할 때는 부담을 주지 않습니다.

러스트를 배우면 나중에 자료형에 진심인 프로그래밍(dependent type, effects
system 등)을 접할 때 덜 이질적이고 도움이 될 수 있다고 생각합니다. 이런 언어는
자료형에 더 많은 정보가 들어있어서 컴파일 때 더 많은 검사를 할 수 있고 위험한
행동을 더 잘 방지합니다.

## 잡담

프로그래밍 언어를 볼 때 기본값이 무엇인지 살펴보면 언어를 만든 사람들의 의도와
철학을 엿볼 수 있습니다. 예를 들어,
* C, C++, Java - 변수는 기본이 가변(mutable), 불변(immutable)이 필요하면
  손가락을 움직여 `const` 추가
* JavaScript - 언젠가부터 가변은 `var`, 불변은 `let`, 둘 모두 세글자
* Rust - 기본이 불변, 가변이 필요하면 `mut` 추가
* Haskell, Erlang - 다른 언어의 variable 개념이 없음, 매번 바뀐 값을 새로 생성

어떤 기능이나 패러다임을 언어가 지원을 하는지 아니면 라이브러리 수준에서
지원하는지도 (즉, 새로운 기능이나 패러다임이 필요할 때 언어가 바꿔야 하는지)
흥미롭습니다. 여러 언어에 비교적 최근에 추가된 Optional 자료형과 optional
chaining operator 그리고 비동기 프레임워크/런타임이 그 예입니다. 러스트에서
`Option`과 `Result`는 표준 라이브러리에 속하지만, `?` 연산자는 언어 자체에
속합니다. 비동기에 대해서 러스트는 `Future`
trait(자료형/인터페이스/typeclass)는 표준 라이브러리에 속하고, `async`와
`await`는 나중에 언어에 키워드로 등장했습니다. 고수준 비동기 기능은 `futures`
crate(라이브러리)를 기반으로, `tokio`와 `async-std` 같은 라이브러리가
공존합니다.

